// app/api/books/by-id/[id]/payload/route.ts
import { NextResponse, type NextRequest } from 'next/server';
import { db } from '@/db/drizzle';
import { and, eq, sql } from 'drizzle-orm';
import { z } from 'zod';
import { chapters } from '@/db';

// Constants
export const dynamic = 'force-dynamic';
export const dynamicParams = true;
export const runtime = 'nodejs';

// Types and Schemas
const PublishOptionsSchema = z.object({
  format: z.enum(['epub']).default('epub'),
  includeMetadata: z.boolean().default(true),
  includeCover: z.boolean().default(true),
  includeTOC: z.boolean().default(true),
  tocLevel: z.number().int().min(1).max(5).default(3),
  includeImprint: z.boolean().default(true),
  language: z.string().default('en'),
  generate_toc: z.boolean().optional(),
  include_imprint: z.boolean().optional(),
  toc_depth: z.number().int().min(1).max(5).optional(),
}).transform(data => ({
  format: data.format,
  includeMetadata: data.includeMetadata,
  includeCover: data.includeCover,
  includeTOC: data.generate_toc ?? data.includeTOC,
  tocLevel: data.toc_depth ?? data.tocLevel,
  includeImprint: data.include_imprint ?? data.includeImprint,
  language: data.language,
}));

// Data Types
interface ChapterNode {
  id: string;
  bookId: string;
  title: string;
  content: string;
  order: number;
  parentChapterId: string | null;
  level: number;
  isDraft: boolean;
  wordCount: number;
  readingTime: number | null;
  children: ChapterNode[];
  slug?: string;
  uuid?: string;
}

interface PayloadChapter {
  id: string;
  title: string;
  slug: string;
  url: string;
  content_url: string;
  content: string;
  order: number;
  parent: string | null;
  title_tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
}

// Helper Functions
function getBaseUrl(request: NextRequest): string {
  const protocol = request.headers.get('x-forwarded-proto') || 'https';
  const host = request.headers.get('host') || 'editor.bookshall.com';
  return `${protocol}://${host}`;
}

async function buildChapterTree(bookId: string): Promise<ChapterNode[]> {
  try {
    const allChapters = await db.select({
      id: chapters.id,
      bookId: chapters.bookId,
      title: chapters.title,
      content: chapters.content,
      order: chapters.order,
      level: chapters.level,
      parentChapterId: chapters.parentChapterId,
      isDraft: chapters.isDraft,
      wordCount: chapters.wordCount,
      readingTime: chapters.readingTime,
      uuid: chapters.uuid,
    }).from(chapters).where(
      and(
        eq(chapters.bookId, bookId),
        eq(chapters.isDraft, false)
      )
    ).orderBy(chapters.order);

    if (allChapters.length === 0) return [];

    const chapterMap = new Map<string, ChapterNode>();
    const rootChapters: ChapterNode[] = [];

    // Create all nodes
    for (const chapter of allChapters) {
      const node: ChapterNode = {
        ...chapter,
        id: String(chapter.id),
        bookId: String(chapter.bookId),
        title: chapter.title || 'Untitled Chapter',
        content: typeof chapter.content === 'string' ? chapter.content : JSON.stringify(chapter.content || ''),
        order: chapter.order ?? 0,
        parentChapterId: chapter.parentChapterId ? String(chapter.parentChapterId) : null,
        level: chapter.level ?? 1,
        isDraft: chapter.isDraft ?? false,
        wordCount: chapter.wordCount ?? 0,
        readingTime: chapter.readingTime ?? null,
        children: [],
        slug: `chapter-${chapter.id}`,
        uuid: chapter.uuid,
      };
      
      chapterMap.set(String(chapter.id), node);
    }

    // Build the tree
    for (const chapter of allChapters) {
      const chapterId = String(chapter.id);
      const node = chapterMap.get(chapterId);
      if (!node) continue;

      if (chapter.parentChapterId) {
        const parentChapterId = String(chapter.parentChapterId);
        const parent = chapterMap.get(parentChapterId);
        if (parent) {
          node.level = parent.level + 1;
          parent.children.push(node);
          continue;
        }
      }
      
      node.level = 1;
      rootChapters.push(node);
    }

    // Sort chapters by order
    const sortChapters = (nodes: ChapterNode[]): ChapterNode[] => {
      return nodes
        .sort((a, b) => a.order - b.order)
        .map(node => ({
          ...node,
          children: sortChapters(node.children),
        }));
    };

    return sortChapters(rootChapters);
  } catch (error) {
    console.error('Error building chapter tree:', error);
    return [];
  }
}

function flattenChapterTree(
  chapters: ChapterNode[],
  bookSlug: string,
  baseUrl: string,
  level = 1,
  parentId: string | null = null
): PayloadChapter[] {
  let result: PayloadChapter[] = [];
  
  for (const chapter of chapters) {
    const slug = `chapter-${chapter.id}`;
    const url = `${baseUrl}/books/${bookSlug}/${slug}`;
    const contentUrl = `${baseUrl}/api/chapters/${chapter.id}/content`;
    
    const payloadChapter: PayloadChapter = {
      id: chapter.id,
      title: chapter.title,
      slug,
      url,
      content_url: contentUrl,
      content: chapter.content,
      order: chapter.order,
      parent: parentId,
      title_tag: `h${Math.min(chapter.level, 6)}` as const,
    };
    
    result.push(payloadChapter);
    
    // Add children recursively
    if (chapter.children.length > 0) {
      result = result.concat(
        flattenChapterTree(chapter.children, bookSlug, baseUrl, level + 1, chapter.id)
      );
    }
  }
  
  return result;
}

// Main Handler
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
): Promise<NextResponse> {
  try {
    const { id: bookId } = params;
    
    if (!bookId) {
      return NextResponse.json(
        { error: 'Book ID is required' },
        { status: 400 }
      );
    }

    // Parse and validate query parameters
    const queryParams = Object.fromEntries(request.nextUrl.searchParams);
    const options = PublishOptionsSchema.parse({
      ...queryParams,
      toc_depth: queryParams.toc_depth || queryParams.tocLevel,
      include_imprint: queryParams.include_imprint || queryParams.includeImprint,
      generate_toc: queryParams.generate_toc || queryParams.includeTOC,
    });
    
    // Get the book
    const book = await db.query.books.findFirst({
      where: (books, { eq }) => eq(books.id, bookId),
      columns: {
        id: true,
        title: true,
        slug: true,
        author: true,
        description: true,
        language: true,
        subtitle: true,
        coverImageUrl: true,
        isPublished: true,
        userId: true,
      },
    });
    
    if (!book) {
      return NextResponse.json(
        { error: 'Book not found' },
        { status: 404 }
      );
    }

    // Skip ownership check in public mode
    console.log('Skipping ownership check in public access mode');

    // Build chapter tree and flatten for payload
    const chapterTree = await buildChapterTree(bookId);
    const baseUrl = getBaseUrl(request);
    const flattenedChapters = flattenChapterTree(chapterTree, book.slug, baseUrl);

    // Prepare response
    const response: EbookPayload = {
      book: {
        slug: book.slug,
        title: book.title,
        author: book.author || 'Unknown Author',
        language: book.language || 'en',
        output_filename: `${book.slug}.epub`,
        cover_url: book.coverImageUrl || '',
        stylesheet_url: `${baseUrl}/styles/epub.css`,
        subtitle: book.subtitle,
        description: book.description,
        chapters: flattenedChapters,
      },
      options: {
        generate_toc: options.includeTOC,
        toc_depth: options.tocLevel,
        embed_metadata: options.includeMetadata,
        include_imprint: options.includeImprint,
        cover: options.includeCover,
      },
      metadata: {
        generated_at: new Date().toISOString(),
        generated_by: 'bookshall-public-api',
        user_id: 'public-access',
      },
    };

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error in GET /api/books/by-id/[id]/payload:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
