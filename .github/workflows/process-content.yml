name: Publish Content

on:
  workflow_dispatch:
    inputs:
      book_id:
        description: 'ID of the book to publish'
        required: true
        type: string
      workflow_id:
        description: 'Internal workflow ID for callbacks'
        required: false
        type: string
      include_metadata:
        description: 'Include metadata in EPUB'
        required: false
        type: boolean
        default: true
      include_cover:
        description: 'Include cover in EPUB'
        required: false
        type: boolean
        default: true
      include_toc:
        description: 'Include table of contents in EPUB'
        required: false
        type: boolean
        default: true
      toc_level:
        description: 'Table of contents depth level'
        required: false
        type: number
        default: 3
      metadata:
        description: 'Additional metadata as JSON string'
        required: false
        type: string
        default: '{}'

jobs:
  publish:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      NODE_ENV: production
      NEXT_PUBLIC_APP_URL: https://bookshall.com
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Inputs
      BOOK_ID: ${{ github.event.inputs.book_id }}
      # Derive CONTENT_ID from BOOK_ID to reduce number of inputs
      CONTENT_ID: ${{ github.event.inputs.book_id }}
      WORKFLOW_ID: ${{ github.event.inputs.workflow_id }}
      INCLUDE_METADATA: ${{ github.event.inputs.include_metadata || 'true' }}
      INCLUDE_COVER: ${{ github.event.inputs.include_cover || 'true' }}
      INCLUDE_TOC: ${{ github.event.inputs.include_toc || 'true' }}
      TOC_LEVEL: ${{ github.event.inputs.toc_level || '3' }}
      METADATA: ${{ github.event.inputs.metadata }}
      
      # Authentication
      BOOKSHALL_API_KEY: ${{ secrets.BOOKSHALL_API_KEY }}

      # Cloudflare R2 (Optional - only if needed)
      R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
      R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET: ${{ secrets.R2_BUCKET }}
      R2_PUBLIC_URL: ${{ secrets.R2_PUBLIC_URL }}
      R2_ENDPOINT: ${{ vars.R2_ENDPOINT }}
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 8.14.3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl unzip pandoc
          # Install AWS CLI v2 (for R2)
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install --update
          aws --version
          pandoc -v

      - name: Install project dependencies
        run: pnpm install --frozen-lockfile

      - name: Make scripts executable
        run: |
          chmod +x ./scripts/validate-inputs.sh
          chmod +x ./scripts/fetch-book.sh
          chmod +x ./scripts/colophon.sh
          chmod +x ./scripts/toc.sh

      - name: Validate inputs
        run: ./scripts/validate-inputs.sh

      - name: Fetch book content
        run: ./scripts/fetch-book.sh

      - name: Upload EPUB to R2
        run: |
          echo "‚òÅÔ∏è Uploading EPUB to Cloudflare R2..."
          EPUB_FILE=$(ls *.epub | head -n1)
          aws s3 cp "$EPUB_FILE" s3://$R2_BUCKET/$CONTENT_ID.epub \
            --endpoint-url="$R2_ENDPOINT"
          echo "‚úÖ Uploaded to R2"
          if [ -n "$R2_PUBLIC_URL" ]; then
            # Use the public URL with /epub/ path
            EXPORT_URL="$R2_PUBLIC_URL/epub/$CONTENT_ID.epub"
          else
            # Fallback to endpoint URL if public URL not configured (shouldn't happen in production)
            echo "‚ö†Ô∏è R2_PUBLIC_URL not set, using R2_ENDPOINT"
            EXPORT_URL="$R2_ENDPOINT/$R2_BUCKET/$CONTENT_ID.epub"
          fi
          echo "üì° Calling back application with EPUB URL: $EXPORT_URL"
          # Resolve workflow ID (prefer input, fallback to metadata.workflowId)
          WF_ID="$WORKFLOW_ID"
          if [ -z "$WF_ID" ] && [ -n "$METADATA" ]; then
            WF_ID=$(echo "$METADATA" | jq -r '.workflowId // empty')
          fi
          CALLBACK_URL="$NEXT_PUBLIC_APP_URL/api/workflows/complete"
          AUTH_HEADER=""
          if [ -n "$BOOKSHALL_API_KEY" ]; then
            AUTH_HEADER="-H 'Authorization: Bearer $BOOKSHALL_API_KEY'"
          elif [ -n "$GITHUB_TOKEN" ]; then
            AUTH_HEADER="-H 'Authorization: Bearer $GITHUB_TOKEN'"
          fi
          curl -fsSL -X POST \
            -H 'Content-Type: application/json' \
            $AUTH_HEADER \
            -d "{\"workflowId\": \"$WF_ID\", \"bookId\": \"$BOOK_ID\", \"epubUrl\": \"$EXPORT_URL\" }" \
            "$CALLBACK_URL" || echo "‚ö†Ô∏è Callback failed"
      
      - name: Upload artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: debug-logs
          path: |
            *.log
            ./logs/
          retention-days: 7
